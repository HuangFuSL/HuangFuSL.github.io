# Python中的序列类型

序列指可以存储多个数据的数据结构。

按照存储的数据类型可以分为：

* 容器可以存储不同类型的数据，这部分类型有`list`、`tuple`、`collections.deque`
* 扁平序列只能存储某种类型的数据，这部分类型有`str`、`bytes`、`bytearray`、`memoryview`、`array.array`

按照序列是否可以修改可以分为

* 可变序列：`list`、`bytearray`、`array.array`、`collections.deque`、`memoryview`
* 不可变序列：`tuple`、`str`、`bytes`

## 列表

列表是可以修改的序列，可以存储多种不同类型的数据结构。如下着重讨论列表推导的书写形式。

列表推导可用于从一个列表生成新的列表，相比于for循环加`append()`方法，列表推导的写法有更好的可读性。

列表推导示例：

```python
a = [1, 2, 3]
b = [_ ** 2 for _ in a]
```

Python 3.x中的列表推导不会产生变量泄露的问题，如下：

```python
x = 'ABC'
y = [x for x in x]
print(x)
```

输出为`ABC`，说明列表推导变量`x`的值没有传递到外部。

列表推导等价于`map`与`filter`的结合。`map`函数接收两个参数。第一个参数为函数，第二个参数为可迭代对象。`map`函数迭代地将函数作用于可迭代对象，从而得到结果。

列表推导可以用于计算列表的笛卡尔积，如下列代码：

```python
[(x, y) for x in range(10) for y in range(11, 20)]
```

循环的顺序与`for`循环一致，先执行外层的循环，再执行内层的循环。

将列表推导的方括号圆括号，即为生成器表达式。如果生成器表达式是函数调用的唯一参数，圆括号可以省略。

## 元组

元组是不可变的序列，可以理解为字段的集合，对应数据表中的某一行。如下着重讨论元组解包的内容。

平行赋值可以将一个可迭代对象中的元素复制到一组变量中。可迭代对象不要求是元组。如：

```python
a, b = (1, 2)
c, d = [3, 4]
e, f = {1: 2, 3: 4} # 按照key的取值进行分配
```

`*`运算符可以用于解包元组中的值作为函数参数，如：

```python
print(*(1, 2))
```

`*`运算符可以用于从函数中获取可变数量的参数，常见用法为`*args`与`**kwargs`。

`*`运算符还可以用于平行赋值中，但平行赋值中的一组变量只能出现一个`*`运算符。带`*`的变量解包后成为列表。

```python
a, b, c, *d = range(5) # d = [3, 4]
a, b, *c, d = range(5) # c = [2, 3]
```

当待解包的元组本身是元组时，可以使用括号解包，如：

```python
a, (b, c), d = (1, (2, 3), 4)
```

元组不支持列表的`append`、`clear`、`copy`、`extend`、`insert`、`pop`、`remove`、`reverse`等方法。

### 具名元组

`collections.namedtuple`提供了用于创建具名元组类型的方法，其参数列表如下：

```python
collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)
```

* `typename`指类型的名称，该变量被写入`__repr__`方法中。该参数的取值与代码中类型被实际分配的名称无关。
* `field_names`是元组中字段的名称
* 当`rename`为`True`重复或与关键字冲突的字段名称会被自动处理，否则会抛出`ValueError`
* `defaults`为字段的默认值，该列表与字段名称列表按右对齐进行匹配。
* 若提供了`module`参数，该值会被写入`__module__`属性中。

`namedtuple`返回可以用于创建对象的类型。

```python
>>> from collections import namedtuple
>>> Point = namedtuple('Point', ["x", "y"], defaults=[1, 2]) 
>>> Point()
Point(x=1, y=2)
>>> Point(2)
Point(x=2, y=2)
>>> Point(2, 3)
Point(x=2, y=3)
>>>
```

## 切片

切片是在序列上执行的操作，切片操作得到一个新的序列。切片以`s[a:b:c]`的形式指定，`a`为起始下标、`b`为终止下标（不包含）、`c`为步长（可以为负）。

* `s[::-1]`等价于反转`s`中的元素
* 切片并没有创建新的对象，对切片的修改会反映到原序列中。但对切片的修改必须满足元素数量相同的条件，否则会抛出`ValueError`。

另一种切片的方式为`s[slice(a, b, c)]`，省略的参数使用`None`表示。因此`s[::-1]`等价于`s[slice(None, None, -1)]`。事实上，Python在处理形如`s[a:b:c]`的切片时会调用`s.__getitem__(slice(start, stop, step))`

在NumPy数组的切片中有时会出现省略的情况，此时可以使用`...`。`...`符号会被Python解释为`EllipsisType`类型的常量。

## 序列运算

序列通常支持`+`运算与`*`运算。与切片不同，这两个运算直接创建一个新的序列。

`+`运算局限于相同类型，对于`list`等可变类型，`a + b`等价于`a.extend(b)`。但`a.extend(b)`方法对`b`的类型无要求，仅需要`b`可迭代。

`*`运算符的第二个操作数`y`必须为整数，表示将序列重复`y`次。若`y<=0`，则返回空列表

**注意**，`*`运算符得到的列表中，列表多次重复的部分以引用的形式存储，如下所示：

```python
>>> b = [[]] * 3
>>> b[0].append(1)
>>> b
[[1], [1], [1]]
>>>
```

`append`处理可变对象的方式同样是复制引用而不是复制值，因此也会造成相同的问题：

```python
>>> a = []
>>> b = []
>>> for i in range(3):
...     a.append(b)
... 
>>> a[0].append(1)
>>> a
[[1], [1], [1]]
>>>
```

因此要避免使用`*`运算符处理包含可变对象的列表。建议使用列表推导创建嵌套列表。